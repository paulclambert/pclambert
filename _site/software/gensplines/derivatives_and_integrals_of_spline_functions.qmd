---
title: "Derivatives and integrals of spline functions."
---



One advantage of using spline functions is that we get analytical
expressions for the derivative and integral of the spline function.

I will illustrate this using B-splines. I first generate some data and plot it.

```stata
. clear

. set obs 1000
Number of observations (_N) was 0, now 1,000.

. range x 0 5

. gen y = 2 + sin(x) + rnormal(0,0.1)

. scatter y x, color(%30) ylabel(0(0.5)3.5, format(%3.1f))

```

![](/statasvg/gensplines_deriv_integ_scatter.svg)


We use B-splines to fit a non-linear function to this data and then obtain
the derivative and integral of this function. 

If our spline function estimate $f(x)$, we can generate the derivative, $f'(x)$ by
obtaining the derivative of each spline variable w.r.t. $x$. 

In `gensplines` this is done by including the dgen() option.


```stata
. gensplines x, type(bs) df(4) gen(_bs) dgen(_dbs)

. global knots `r(knots)'

. regress y _bs*

      Source |       SS           df       MS      Number of obs   =     1,000
-------------+----------------------------------   F(4, 995)       =  11523.91
       Model |  499.420658         4  124.855165   Prob > F        =    0.0000
    Residual |  10.7802719       995  .010834444   R-squared       =    0.9789
-------------+----------------------------------   Adj R-squared   =    0.9788
       Total |   510.20093       999  .510711642   Root MSE        =    .10409

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
        _bs1 |   1.157355   .0321722    35.97   0.000     1.094222    1.220488
        _bs2 |    1.40694   .0250554    56.15   0.000     1.357772    1.456107
        _bs3 |   -1.31531    .028641   -45.92   0.000    -1.371514   -1.259106
        _bs4 |   -.845699   .0207244   -40.81   0.000    -.8863675   -.8050306
       _cons |   1.938942   .0157018   123.49   0.000     1.908129    1.969754
------------------------------------------------------------------------------

. predict mu
(option xb assumed; fitted values)

```
Below I add the fitted regression line to the scatter plot 

```stata
. twoway (scatter y x, color(%30))         ///
>        (line mu x, sort),                ///
>        ylabel(0(0.5)3.5, format(%3.1f))  ///
>        legend(off)

```

![](/statasvg/gensplines_deriv_integ_scatter_fit.svg)

       
To generate the dervative of the fitted function we can  multipy the
coefficients by the variables created by the dgen() option, 
the derivative of each spline variable w.r.t. $x$..

```stata
. gen double deriv1 = _b[_bs1]*_dbs1 + _b[_bs2]*_dbs2 + _b[_bs3]*_dbs3 + _b[_bs4]*_dbs4      

```
As a comparison I calculate the derivatives numerically using the `dydx` command.

```stata
. dydx mu x, gen(deriv2) double

. compare deriv1 deriv2

                                        ---------- Difference ----------
                            Count       Minimum      Average     Maximum
------------------------------------------------------------------------
deriv1<deriv2                 484     -2.21e-06    -6.89e-09   -1.25e-16
deriv1=deriv2                   1
deriv1>deriv2                 515      2.22e-16     2.05e-08    8.25e-06
                       ----------
Jointly defined              1000     -2.21e-06     7.24e-09    8.25e-06
                       ----------
Total                        1000

```
We can plot the function and can see that the derivative is zero at the turning
points of the original function.

```stata
. line deriv2 x

```

![](/statasvg/gensplines_deriv_integ_deriv_plot.svg)


In order to calculate the integral of the function we need to generate the
integral of each of the spline variables. This can be done by using
the `type(ibs)` option of `gensplines`. 
If we use `df(4)` as above, then the knots will be in 
exactly the same location. Alternatively, we could have saved the knots
when we generated the original spline variables and used the `allknots()` option.

```stata
. gensplines x, type(ibs) df(4) gen(_ibs) 

```
We need to integrate the intercept and then incude the integrated spline functions
and multiply each by the associated coefficient.
```stata
. gen double integ1 = _b[_cons]*x + _b[_bs1]*_ibs1 + _b[_bs2]*_ibs2 + _b[_bs3]*_ibs3 + _b[_bs
> 4]*_ibs4      

```

We can compare to the numerically integrated function.
```stata
. integ mu x, gen(integ2) double

number of points = 1000

integral         = 10.727378

. compare integ1 integ2

                                        ---------- Difference ----------
                            Count       Minimum      Average     Maximum
------------------------------------------------------------------------
integ1<integ2                   1     -1.39e-11    -1.39e-11   -1.39e-11
integ1=integ2                   1
integ1>integ2                 998      8.87e-13     2.66e-12    7.98e-12
                       ----------
Jointly defined              1000     -1.39e-11     2.64e-12    7.98e-12
                       ----------
Total                        1000

```
And plot the integral at each value of `x`.
```stata
. line integ1 x

```

![](/statasvg/gensplines_deriv_integ_integ_plot.svg)


If we are just interested in the integral at one value of x, we 
just pass this value to `gensplines`. For example, the integral at
`x=5` is,

```stata
. gensplines 5, type(ibs) allknots(${knots}) gen(_k) 

. lincom _b[_cons]*5 + _b[_bs1]*_k1 + _b[_bs2]*_k2 + _b[_bs3]*_k3 + _b[_bs4]*_k4

 ( 1)  1.25*_bs1 + 1.25*_bs2 + 1.25*_bs3 + .625*_bs4 + 5*_cons = 0

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
         (1) |   10.72738    .016458   651.80   0.000     10.69508    10.75967
------------------------------------------------------------------------------

```

Note we also get a confidence interval for the integral as I used `lincom`.


Adding the integral of the intercept can be avoided by generating an extra
spline variable and then using the `nonconstant` option when fitting the model.
Below I do this and then obtain the integral in a frame. By naming the 
integrated B-spline variables the same as the spline variables, I can use 
the `predict` command to obtain the integrated function.

```stata
. drop _*

. gensplines x, type(bs) df(4) gen(_bs) intercept

. regress y _bs*, nocons

      Source |       SS           df       MS      Number of obs   =     1,000
-------------+----------------------------------   F(5, 995)       =  94140.21
       Model |  5099.78427         5  1019.95685   Prob > F        =    0.0000
    Residual |  10.7802719       995  .010834444   R-squared       =    0.9979
-------------+----------------------------------   Adj R-squared   =    0.9979
       Total |  5110.56454     1,000  5.11056454   Root MSE        =    .10409

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
        _bs1 |   1.938942   .0157018   123.49   0.000     1.908129    1.969754
        _bs2 |   3.096297   .0200698   154.28   0.000     3.056913    3.135681
        _bs3 |   3.345881   .0272985   122.57   0.000     3.292312     3.39945
        _bs4 |   .6236317   .0200698    31.07   0.000     .5842476    .6630157
        _bs5 |   1.093243   .0157018    69.63   0.000      1.06243    1.124055
------------------------------------------------------------------------------

.  
. cap frame drop integral

. frame put y x, into(integral)

. frame integral {
.   gensplines x, type(ibs) df(4) gen(_bs) intercept
.   predict mu,
(option xb assumed; fitted values)
.   line mu x, ytitle(Integral of fitted values)
. }

```


